<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harmony Audio Visualizer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.3/font/bootstrap-icons.css">
    <style>
        :root {
            --primary-color: #4a6bff;
            --primary-light: #6d87ff;
            --primary-dark: #3a56cc;
            --accent-color: #ff6b6b;
            --secondary-color: #6c5ce7;
            --text-primary: #2c3e50;
            --text-secondary: #5a6c7d;
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #e9ecef;
            --shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
            --shadow-hover: 0 12px 40px rgba(0, 0, 0, 0.12);
            --border-radius: 16px;
            --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #e4edf5 100%);
            color: var(--text-primary);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .container {
            max-width: 900px;
            animation: slideUp 0.6s ease-out 0.2s both;
        }

        @keyframes slideUp {
            from { transform: translateY(30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .player-container {
            background-color: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: 30px;
            box-shadow: var(--shadow);
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .player-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(to right, var(--primary-color), var(--accent-color));
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.8s ease;
        }

        .player-container.loaded::before {
            transform: scaleX(1);
        }

        .player-container:hover {
            box-shadow: var(--shadow-hover);
            transform: translateY(-5px);
        }

        .visualization-container {
            background: linear-gradient(to bottom, var(--bg-secondary), var(--bg-tertiary));
            border-radius: 12px;
            height: 250px;
            position: relative;
            overflow: hidden;
            margin-bottom: 25px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
            transition: var(--transition);
        }

        #visualization {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #visualization-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .visualization-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }

        .visualization-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.7);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .visualization-container:hover .visualization-title {
            opacity: 1;
        }

        .controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 25px 0;
        }

        .btn-control {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            border: none;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .btn-control:hover {
            background-color: var(--primary-color);
            color: white;
            transform: scale(1.1) rotate(5deg);
            box-shadow: 0 6px 12px rgba(74, 107, 255, 0.3);
        }

        .btn-control:active {
            transform: scale(0.95);
        }

        .btn-play {
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, var(--primary-color), var(--primary-light));
            color: white;
            box-shadow: 0 6px 15px rgba(74, 107, 255, 0.4);
            animation: pulse-glow 2s infinite alternate;
        }

        @keyframes pulse-glow {
            0% { box-shadow: 0 6px 15px rgba(74, 107, 255, 0.4); }
            100% { box-shadow: 0 6px 20px rgba(74, 107, 255, 0.6); }
        }

        .btn-play:hover {
            background: linear-gradient(135deg, var(--primary-dark), var(--primary-color));
            transform: scale(1.15);
        }

        .progress-container {
            width: 100%;
            height: 8px;
            background-color: var(--bg-tertiary);
            border-radius: 4px;
            margin: 15px 0;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(to right, var(--primary-color), var(--accent-color));
            border-radius: 4px;
            width: 0%;
            transition: width 0.1s linear;
            position: relative;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 10px;
            background-color: white;
            border-radius: 50%;
            transform: translateX(50%);
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }

        .time-display {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 5px;
        }

        .volume-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }

        .volume-slider {
            width: 100px;
            cursor: pointer;
        }

        .track-info {
            text-align: center;
            margin-bottom: 25px;
            transition: var(--transition);
        }

        .track-title {
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: var(--text-primary);
            transition: var(--transition);
        }

        .track-artist {
            font-size: 1rem;
            color: var(--text-secondary);
            transition: var(--transition);
        }

        .visualization-modes {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .mode-btn {
            background-color: var(--bg-secondary);
            color: var(--text-secondary);
            border: none;
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: var(--transition);
        }

        .mode-btn.active {
            background: linear-gradient(to right, var(--primary-color), var(--primary-light));
            color: white;
            box-shadow: 0 4px 10px rgba(74, 107, 255, 0.3);
        }

        .mode-btn:hover:not(.active) {
            background-color: var(--bg-tertiary);
            transform: translateY(-2px);
        }

        .file-drop-area {
            border: 2px dashed #cbd5e0;
            border-radius: 12px;
            padding: 30px 20px;
            text-align: center;
            margin-bottom: 25px;
            transition: var(--transition);
            background-color: var(--bg-secondary);
            cursor: pointer;
        }

        .file-drop-area.highlight {
            border-color: var(--primary-color);
            background-color: rgba(74, 107, 255, 0.05);
            transform: scale(1.02);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }

        .file-drop-area i {
            font-size: 2.5rem;
            color: var(--primary-color);
            margin-bottom: 10px;
            transition: var(--transition);
        }

        .file-drop-area:hover i {
            transform: translateY(-5px);
        }

        .file-input {
            display: none;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(to right, var(--primary-color), var(--primary-light));
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            transform: translateX(120%);
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 1000;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .notification.show {
            transform: translateX(0);
        }

        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .player-title {
            font-size: 1.8rem;
            font-weight: 700;
            background: linear-gradient(to right, var(--primary-color), var(--accent-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0;
        }

        .player-stats {
            display: flex;
            gap: 15px;
        }

        .stat {
            background-color: var(--bg-secondary);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.85rem;
            color: var(--text-secondary);
            transition: var(--transition);
        }

        .stat:hover {
            background-color: var(--primary-color);
            color: white;
            transform: translateY(-2px);
        }

        .wave-animation {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 10px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
            animation: wave 3s infinite linear;
            opacity: 0.5;
        }

        @keyframes wave {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .rotating {
            animation: rotate 10s infinite linear;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .floating {
            animation: float 6s ease-in-out infinite;
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        .visualization-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .control-btn {
            background-color: var(--bg-secondary);
            border: none;
            border-radius: 20px;
            padding: 6px 12px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: var(--transition);
        }

        .control-btn:hover {
            background-color: var(--primary-color);
            color: white;
            transform: translateY(-2px);
        }

        .control-btn.active {
            background-color: var(--primary-color);
            color: white;
        }

        .particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="player-container" id="playerContainer">
            <div class="player-header">
                <h1 class="player-title">Harmony Visualizer</h1>
                <div class="player-stats">
                    <div class="stat">
                        <i class="bi bi-music-note-beamed"></i> <span id="trackCount">0 tracks</span>
                    </div>
                    <div class="stat">
                        <i class="bi bi-clock"></i> <span id="totalDuration">0:00</span>
                    </div>
                </div>
            </div>
            
            <div class="file-drop-area" id="dropArea">
                <p><i class="bi bi-cloud-upload floating"></i></p>
                <p>Drag & drop your audio file here or</p>
                <button class="btn btn-outline-primary btn-sm" id="browseBtn">Browse Files</button>
                <input type="file" id="fileInput" class="file-input" accept="audio/*">
            </div>

            <div class="track-info">
                <div class="track-title" id="trackTitle">No track selected</div>
                <div class="track-artist" id="trackArtist">Upload an audio file to begin</div>
            </div>

            <div class="visualization-controls">
                <button class="control-btn active" id="colorModeBtn" data-mode="gradient">Gradient Colors</button>
                <button class="control-btn" id="particleModeBtn" data-mode="particles">Particles</button>
                <button class="control-btn" id="mirrorModeBtn" data-mode="mirror">Mirror Effect</button>
            </div>

            <div class="visualization-modes">
                <button class="mode-btn active" data-mode="bars">Bars</button>
                <button class="mode-btn" data-mode="circle">Circle</button>
                <button class="mode-btn" data-mode="wave">Wave</button>
                <button class="mode-btn" data-mode="line">Line</button>
                <button class="mode-btn" data-mode="particles">Particles</button>
                <button class="mode-btn" data-mode="spiral">Spiral</button>
                <button class="mode-btn" data-mode="radial">Radial</button>
            </div>

            <div class="visualization-container">
                <div class="wave-animation"></div>
                <canvas id="visualization-canvas"></canvas>
                <div class="visualization-overlay">
                    <div class="visualization-title" id="visualizationTitle">Bars Visualization</div>
                </div>
            </div>

            <div class="progress-container" id="progressContainer">
                <div class="progress-bar" id="progressBar"></div>
            </div>

            <div class="time-display">
                <span id="currentTime">0:00</span>
                <span id="totalTime">0:00</span>
            </div>

            <div class="controls">
                <button class="btn-control" id="btnPrev">
                    <i class="bi bi-skip-backward-fill"></i>
                </button>
                <button class="btn-control btn-play" id="btnPlay">
                    <i class="bi bi-play-fill" id="playIcon"></i>
                </button>
                <button class="btn-control" id="btnNext">
                    <i class="bi bi-skip-forward-fill"></i>
                </button>
            </div>

            <div class="volume-container">
                <i class="bi bi-volume-down"></i>
                <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="70">
                <i class="bi bi-volume-up"></i>
            </div>
        </div>
    </div>

    <div class="notification" id="notification">
        <span id="notificationText"></span>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // DOM Elements
            const playerContainer = document.getElementById('playerContainer');
            const dropArea = document.getElementById('dropArea');
            const fileInput = document.getElementById('fileInput');
            const browseBtn = document.getElementById('browseBtn');
            const trackTitle = document.getElementById('trackTitle');
            const trackArtist = document.getElementById('trackArtist');
            const visualizationCanvas = document.getElementById('visualization-canvas');
            const visualizationTitle = document.getElementById('visualizationTitle');
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const currentTimeEl = document.getElementById('currentTime');
            const totalTimeEl = document.getElementById('totalTime');
            const btnPlay = document.getElementById('btnPlay');
            const playIcon = document.getElementById('playIcon');
            const volumeSlider = document.getElementById('volumeSlider');
            const notification = document.getElementById('notification');
            const notificationText = document.getElementById('notificationText');
            const trackCount = document.getElementById('trackCount');
            const totalDuration = document.getElementById('totalDuration');
            const btnPrev = document.getElementById('btnPrev');
            const btnNext = document.getElementById('btnNext');
            const modeButtons = document.querySelectorAll('.mode-btn');
            const colorModeBtn = document.getElementById('colorModeBtn');
            const particleModeBtn = document.getElementById('particleModeBtn');
            const mirrorModeBtn = document.getElementById('mirrorModeBtn');

            // Canvas context
            const canvasCtx = visualizationCanvas.getContext('2d');

            // Audio context and variables
            let audioContext;
            let analyser;
            let source;
            let audio = new Audio();
            let isPlaying = false;
            let tracks = [];
            let currentTrackIndex = 0;
            let visualizationMode = 'bars';
            let colorMode = 'gradient';
            let useParticles = false;
            let useMirror = false;
            let particles = [];

            // Set canvas size
            function setCanvasSize() {
                const container = visualizationCanvas.parentElement;
                visualizationCanvas.width = container.clientWidth;
                visualizationCanvas.height = container.clientHeight;
            }

            // Format time from seconds to MM:SS
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
            }

            // Show notification
            function showNotification(message) {
                notificationText.textContent = message;
                notification.classList.add('show');
                
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 3000);
            }

            // Load track
            function loadTrack(file, index) {
                if (!file) return;
                
                const url = URL.createObjectURL(file);
                audio.src = url;
                
                // Extract filename for display
                const fileName = file.name.replace(/\.[^/.]+$/, "");
                trackTitle.textContent = fileName;
                trackArtist.textContent = 'Uploaded Track';
                
                // Update track info
                tracks[currentTrackIndex] = {
                    file: file,
                    name: fileName,
                    duration: 0
                };
                
                // Set up audio context and analyser when first track is loaded
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    source = audioContext.createMediaElementSource(audio);
                    source.connect(analyser);
                    analyser.connect(audioContext.destination);
                    
                    analyser.fftSize = 256;
                    
                    // Set canvas size
                    setCanvasSize();
                    window.addEventListener('resize', setCanvasSize);
                }
                
                // Update player stats
                updatePlayerStats();
                
                // When metadata is loaded, update duration
                audio.addEventListener('loadedmetadata', function() {
                    totalTimeEl.textContent = formatTime(audio.duration);
                    tracks[currentTrackIndex].duration = audio.duration;
                    updatePlayerStats();
                });
                
                // Add player loaded class for animations
                playerContainer.classList.add('loaded');
                
                showNotification(`Loaded: ${fileName}`);
            }

            // Update player statistics
            function updatePlayerStats() {
                trackCount.textContent = `${tracks.length} track${tracks.length !== 1 ? 's' : ''}`;
                
                let totalSeconds = tracks.reduce((total, track) => total + track.duration, 0);
                totalDuration.textContent = formatTime(totalSeconds);
            }

            // Play/pause audio
            function togglePlayback() {
                if (!audio.src) {
                    showNotification('Please select an audio file first');
                    return;
                }
                
                if (isPlaying) {
                    audio.pause();
                    playIcon.className = 'bi bi-play-fill';
                    isPlaying = false;
                } else {
                    // Resume audio context if suspended (required by some browsers)
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                    
                    audio.play();
                    playIcon.className = 'bi bi-pause-fill';
                    isPlaying = true;
                    
                    // Start visualization
                    visualize();
                }
            }

            // Get color based on frequency and position
            function getColor(value, maxValue, position, totalPositions) {
                switch(colorMode) {
                    case 'gradient':
                        const hue = (value / maxValue) * 120 + 200;
                        return `hsl(${hue}, 70%, 60%)`;
                    case 'rainbow':
                        const hue2 = (position / totalPositions) * 360;
                        return `hsl(${hue2}, 80%, 60%)`;
                    case 'fire':
                        const r = Math.min(255, value * 10);
                        const g = Math.min(255, value * 5);
                        return `rgb(${r}, ${g}, 0)`;
                    default:
                        return `hsl(220, 70%, 60%)`;
                }
            }

            // Create particles
            function createParticles(dataArray, bufferLength) {
                if (!useParticles) return;
                
                // Remove old particles randomly
                particles = particles.filter(p => Math.random() > 0.02);
                
                // Create new particles
                for (let i = 0; i < bufferLength; i += 4) {
                    if (Math.random() < dataArray[i] / 255 * 0.1) {
                        const value = dataArray[i];
                        const x = Math.random() * visualizationCanvas.width;
                        const y = Math.random() * visualizationCanvas.height;
                        const size = Math.random() * 5 + 1;
                        const speedX = (Math.random() - 0.5) * 5;
                        const speedY = (Math.random() - 0.5) * 5;
                        const color = getColor(value, 255, i, bufferLength);
                        
                        particles.push({
                            x, y, size, speedX, speedY, color,
                            life: 100,
                            opacity: 1
                        });
                    }
                }
                
                // Update and draw particles
                particles.forEach(particle => {
                    particle.x += particle.speedX;
                    particle.y += particle.speedY;
                    particle.life--;
                    particle.opacity = particle.life / 100;
                    
                    if (particle.life <= 0) {
                        particle.life = 0;
                    }
                    
                    canvasCtx.globalAlpha = particle.opacity;
                    canvasCtx.fillStyle = particle.color;
                    canvasCtx.beginPath();
                    canvasCtx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    canvasCtx.fill();
                });
                
                canvasCtx.globalAlpha = 1;
            }

            // Visualization functions
            const visualizationFunctions = {
                bars: function(dataArray, bufferLength) {
                    const barWidth = visualizationCanvas.width / bufferLength;
                    let x = 0;
                    
                    for (let i = 0; i < bufferLength; i++) {
                        const barHeight = (dataArray[i] / 255) * visualizationCanvas.height;
                        
                        const color = getColor(dataArray[i], 255, i, bufferLength);
                        canvasCtx.fillStyle = color;
                        
                        if (useMirror) {
                            // Draw top bar
                            canvasCtx.fillRect(x, visualizationCanvas.height / 2 - barHeight, barWidth, barHeight);
                            // Draw bottom bar (mirrored)
                            canvasCtx.fillRect(x, visualizationCanvas.height / 2, barWidth, barHeight);
                        } else {
                            canvasCtx.fillRect(x, visualizationCanvas.height - barHeight, barWidth, barHeight);
                        }
                        
                        x += barWidth;
                    }
                    
                    if (useParticles) createParticles(dataArray, bufferLength);
                },
                
                circle: function(dataArray, bufferLength) {
                    const centerX = visualizationCanvas.width / 2;
                    const centerY = visualizationCanvas.height / 2;
                    const radius = Math.min(centerX, centerY) * 0.7;
                    
                    canvasCtx.beginPath();
                    
                    for (let i = 0; i < bufferLength; i++) {
                        const angle = (i / bufferLength) * Math.PI * 2;
                        const value = dataArray[i];
                        const barHeight = (value / 255) * radius * 0.5;
                        
                        const x1 = centerX + Math.cos(angle) * radius;
                        const y1 = centerY + Math.sin(angle) * radius;
                        const x2 = centerX + Math.cos(angle) * (radius + barHeight);
                        const y2 = centerY + Math.sin(angle) * (radius + barHeight);
                        
                        const color = getColor(value, 255, i, bufferLength);
                        canvasCtx.strokeStyle = color;
                        canvasCtx.lineWidth = 2;
                        
                        canvasCtx.beginPath();
                        canvasCtx.moveTo(x1, y1);
                        canvasCtx.lineTo(x2, y2);
                        canvasCtx.stroke();
                    }
                    
                    if (useParticles) createParticles(dataArray, bufferLength);
                },
                
                wave: function(dataArray, bufferLength) {
                    canvasCtx.beginPath();
                    canvasCtx.lineWidth = 2;
                    
                    const sliceWidth = visualizationCanvas.width / bufferLength;
                    let x = 0;
                    
                    for (let i = 0; i < bufferLength; i++) {
                        const v = dataArray[i] / 255;
                        const y = v * visualizationCanvas.height;
                        
                        if (i === 0) {
                            canvasCtx.moveTo(x, y);
                        } else {
                            canvasCtx.lineTo(x, y);
                        }
                        
                        x += sliceWidth;
                    }
                    
                    if (useMirror) {
                        canvasCtx.lineTo(visualizationCanvas.width, visualizationCanvas.height / 2);
                        
                        // Draw mirrored wave
                        x = visualizationCanvas.width;
                        for (let i = bufferLength - 1; i >= 0; i--) {
                            const v = dataArray[i] / 255;
                            const y = visualizationCanvas.height - (v * visualizationCanvas.height);
                            
                            canvasCtx.lineTo(x, y);
                            x -= sliceWidth;
                        }
                        canvasCtx.closePath();
                    } else {
                        canvasCtx.lineTo(visualizationCanvas.width, visualizationCanvas.height / 2);
                    }
                    
                    const gradient = canvasCtx.createLinearGradient(0, 0, visualizationCanvas.width, 0);
                    gradient.addColorStop(0, getColor(dataArray[0], 255, 0, bufferLength));
                    gradient.addColorStop(1, getColor(dataArray[bufferLength-1], 255, bufferLength-1, bufferLength));
                    
                    canvasCtx.strokeStyle = gradient;
                    canvasCtx.stroke();
                    
                    if (useMirror) {
                        canvasCtx.fillStyle = gradient;
                        canvasCtx.globalAlpha = 0.2;
                        canvasCtx.fill();
                        canvasCtx.globalAlpha = 1;
                    }
                    
                    if (useParticles) createParticles(dataArray, bufferLength);
                },
                
                line: function(dataArray, bufferLength) {
                    canvasCtx.beginPath();
                    canvasCtx.lineWidth = 3;
                    
                    const sliceWidth = visualizationCanvas.width / bufferLength;
                    let x = 0;
                    
                    for (let i = 0; i < bufferLength; i++) {
                        const v = dataArray[i] / 128.0;
                        const y = (v * visualizationCanvas.height) / 2;
                        
                        if (i === 0) {
                            canvasCtx.moveTo(x, y);
                        } else {
                            canvasCtx.lineTo(x, y);
                        }
                        
                        x += sliceWidth;
                    }
                    
                    const gradient = canvasCtx.createLinearGradient(0, 0, visualizationCanvas.width, 0);
                    gradient.addColorStop(0, getColor(dataArray[0], 255, 0, bufferLength));
                    gradient.addColorStop(1, getColor(dataArray[bufferLength-1], 255, bufferLength-1, bufferLength));
                    
                    canvasCtx.strokeStyle = gradient;
                    canvasCtx.stroke();
                    
                    if (useParticles) createParticles(dataArray, bufferLength);
                },
                
                particles: function(dataArray, bufferLength) {
                    // Clear canvas with a slight fade effect
                    canvasCtx.fillStyle = 'rgba(248, 249, 250, 0.1)';
                    canvasCtx.fillRect(0, 0, visualizationCanvas.width, visualizationCanvas.height);
                    
                    // Create particles based on audio data
                    for (let i = 0; i < bufferLength; i++) {
                        if (dataArray[i] > 128 && Math.random() < 0.3) {
                            const x = Math.random() * visualizationCanvas.width;
                            const y = Math.random() * visualizationCanvas.height;
                            const size = (dataArray[i] / 255) * 10 + 2;
                            const speedX = (Math.random() - 0.5) * 5;
                            const speedY = (Math.random() - 0.5) * 5;
                            const color = getColor(dataArray[i], 255, i, bufferLength);
                            
                            particles.push({
                                x, y, size, speedX, speedY, color,
                                life: 100,
                                opacity: 1
                            });
                        }
                    }
                    
                    // Update and draw particles
                    particles.forEach((particle, index) => {
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        particle.life--;
                        particle.opacity = particle.life / 100;
                        
                        if (particle.life <= 0 || 
                            particle.x < 0 || particle.x > visualizationCanvas.width ||
                            particle.y < 0 || particle.y > visualizationCanvas.height) {
                            particles.splice(index, 1);
                        } else {
                            canvasCtx.globalAlpha = particle.opacity;
                            canvasCtx.fillStyle = particle.color;
                            canvasCtx.beginPath();
                            canvasCtx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                            canvasCtx.fill();
                        }
                    });
                    
                    canvasCtx.globalAlpha = 1;
                },
                
                spiral: function(dataArray, bufferLength) {
                    const centerX = visualizationCanvas.width / 2;
                    const centerY = visualizationCanvas.height / 2;
                    const maxRadius = Math.min(centerX, centerY) * 0.8;
                    
                    canvasCtx.beginPath();
                    
                    for (let i = 0; i < bufferLength; i++) {
                        const angle = (i / bufferLength) * Math.PI * 8; // 4 full rotations
                        const radius = (i / bufferLength) * maxRadius;
                        const value = dataArray[i];
                        const barHeight = (value / 255) * 30;
                        
                        const x1 = centerX + Math.cos(angle) * radius;
                        const y1 = centerY + Math.sin(angle) * radius;
                        const x2 = centerX + Math.cos(angle) * (radius + barHeight);
                        const y2 = centerY + Math.sin(angle) * (radius + barHeight);
                        
                        const color = getColor(value, 255, i, bufferLength);
                        canvasCtx.strokeStyle = color;
                        canvasCtx.lineWidth = 2;
                        
                        canvasCtx.beginPath();
                        canvasCtx.moveTo(x1, y1);
                        canvasCtx.lineTo(x2, y2);
                        canvasCtx.stroke();
                    }
                    
                    if (useParticles) createParticles(dataArray, bufferLength);
                },
                
                radial: function(dataArray, bufferLength) {
                    const centerX = visualizationCanvas.width / 2;
                    const centerY = visualizationCanvas.height / 2;
                    const maxRadius = Math.min(centerX, centerY) * 0.7;
                    
                    for (let i = 0; i < bufferLength; i++) {
                        const angle = (i / bufferLength) * Math.PI * 2;
                        const value = dataArray[i];
                        const radius = (value / 255) * maxRadius;
                        
                        const x = centerX + Math.cos(angle) * radius;
                        const y = centerY + Math.sin(angle) * radius;
                        
                        const color = getColor(value, 255, i, bufferLength);
                        canvasCtx.fillStyle = color;
                        
                        canvasCtx.beginPath();
                        canvasCtx.arc(x, y, 3, 0, Math.PI * 2);
                        canvasCtx.fill();
                    }
                    
                    if (useParticles) createParticles(dataArray, bufferLength);
                }
            };

            // Visualization function
            function visualize() {
                if (!isPlaying) return;
                
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                function draw() {
                    if (!isPlaying) return;
                    
                    requestAnimationFrame(draw);
                    
                    analyser.getByteFrequencyData(dataArray);
                    
                    // Clear canvas
                    canvasCtx.fillStyle = 'rgb(248, 249, 250)';
                    canvasCtx.fillRect(0, 0, visualizationCanvas.width, visualizationCanvas.height);
                    
                    // Draw visualization based on current mode
                    if (visualizationFunctions[visualizationMode]) {
                        visualizationFunctions[visualizationMode](dataArray, bufferLength);
                    }
                }
                
                draw();
            }

            // Update progress bar
            audio.addEventListener('timeupdate', function() {
                if (audio.duration) {
                    const progressPercent = (audio.currentTime / audio.duration) * 100;
                    progressBar.style.width = `${progressPercent}%`;
                    currentTimeEl.textContent = formatTime(audio.currentTime);
                }
            });

            // Click on progress bar to seek
            progressContainer.addEventListener('click', function(e) {
                if (!audio.src) return;
                
                const rect = progressContainer.getBoundingClientRect();
                const percent = (e.clientX - rect.left) / rect.width;
                audio.currentTime = percent * audio.duration;
            });

            // Volume control
            volumeSlider.addEventListener('input', function() {
                audio.volume = volumeSlider.value / 100;
            });

            // File input handling
            browseBtn.addEventListener('click', function() {
                fileInput.click();
            });

            fileInput.addEventListener('change', function() {
                if (this.files.length > 0) {
                    const file = this.files[0];
                    currentTrackIndex = tracks.length;
                    tracks.push({});
                    loadTrack(file, currentTrackIndex);
                }
            });

            // Drag and drop handling
            dropArea.addEventListener('dragover', function(e) {
                e.preventDefault();
                dropArea.classList.add('highlight');
            });

            dropArea.addEventListener('dragleave', function() {
                dropArea.classList.remove('highlight');
            });

            dropArea.addEventListener('drop', function(e) {
                e.preventDefault();
                dropArea.classList.remove('highlight');
                
                if (e.dataTransfer.files.length > 0) {
                    const file = e.dataTransfer.files[0];
                    if (file.type.startsWith('audio/')) {
                        currentTrackIndex = tracks.length;
                        tracks.push({});
                        loadTrack(file, currentTrackIndex);
                    } else {
                        showNotification('Please select an audio file');
                    }
                }
            });

            // Play button event
            btnPlay.addEventListener('click', togglePlayback);

            // Previous and Next buttons
            btnPrev.addEventListener('click', function() {
                if (tracks.length > 1) {
                    currentTrackIndex = (currentTrackIndex - 1 + tracks.length) % tracks.length;
                    loadTrack(tracks[currentTrackIndex].file, currentTrackIndex);
                    if (isPlaying) {
                        audio.play();
                    }
                } else {
                    showNotification('No previous track available');
                }
            });

            btnNext.addEventListener('click', function() {
                if (tracks.length > 1) {
                    currentTrackIndex = (currentTrackIndex + 1) % tracks.length;
                    loadTrack(tracks[currentTrackIndex].file, currentTrackIndex);
                    if (isPlaying) {
                        audio.play();
                    }
                } else {
                    showNotification('No next track available');
                }
            });

            // Visualization mode buttons
            modeButtons.forEach(button => {
                button.addEventListener('click', function() {
                    modeButtons.forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    visualizationMode = this.getAttribute('data-mode');
                    visualizationTitle.textContent = `${this.textContent} Visualization`;
                    showNotification(`Visualization: ${this.textContent}`);
                });
            });

            // Color mode buttons
            colorModeBtn.addEventListener('click', function() {
                colorModeBtn.classList.add('active');
                particleModeBtn.classList.remove('active');
                mirrorModeBtn.classList.remove('active');
                colorMode = 'gradient';
                useParticles = false;
                useMirror = false;
                showNotification('Color Mode: Gradient');
            });

            particleModeBtn.addEventListener('click', function() {
                particleModeBtn.classList.add('active');
                colorModeBtn.classList.remove('active');
                mirrorModeBtn.classList.remove('active');
                useParticles = true;
                useMirror = false;
                showNotification('Effect: Particles Enabled');
            });

            mirrorModeBtn.addEventListener('click', function() {
                mirrorModeBtn.classList.add('active');
                colorModeBtn.classList.remove('active');
                particleModeBtn.classList.remove('active');
                useMirror = true;
                useParticles = false;
                showNotification('Effect: Mirror Enabled');
            });

            // Initialize
            setCanvasSize();
            showNotification('Welcome to Harmony Visualizer!');
        });
    </script>
</body>
</html>